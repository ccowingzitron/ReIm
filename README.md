# ReIm
ReIm provides a drop-in replacement for std::complex< T > which fully supports arbitrary real types T and mixed-precision arithmetic.

Did you know that in C++ you cannot multiply a float and a std::complex< double > ? Neither did I until I tried and it wouldn't compile. I read the standard, and nope, they never mention mixed-precision real/complex arithmetic.

Did you also know that you cannot directly access the real and imaginary parts of a std::complex< T > ? This is in spite of the fact the standard explicitly states, for a std::complex< T > "c", that "reinterpret_cast< T (&) [2] >(c)[0]" is the real part and "reinterpret_cast< T (&) [2]  >(c)[1]" is the imaginary part. This necessarily restricts a std::complex< T > to being a standard layout class with only two non-static data members, both of type T, the real part and the imaginary part, in that order. The whole reason for this is restriction is compatibility with other languages, like C and Fortran, which support complex arithmetic types with that layout.

Did you also know that the standard explicitly states that instantiating a std::complex< T > with T being anything other than "float", "double", or "long double" results in undefined behavior? But what if I have another real number, a perfectly fine real number, say for arbitrary precision arithmetic, which implements all the necessary operators for real arithmetic, and I just want to complexify it? Well, too bad.

Well, fudge that. CZ::ReIm< T > (I'm CZ in that namespace) wraps an arbitrary real numeric type in a standard-conformant, layout-compatible struct that does everything it should do, the way you think it should, without complaining that you and your "float * CZ::ReIm< double >" are just too fancy. The only data member is "T reIm [2]" and "reIm [0]" is the real part, and "reIm [1]" is the imaginary part. It's almost too impressive to believe. The only thing your real type T needs to implement are (1) the four major arithmetic operators, (2) std::numeric_limits< T >::digits (that's the only part of std::numeric_limits< T > that we use to implement the mixed-precision-iosity), (3) the implicit conversion and copy-constructors to and from whatever other real types you'd like to interoperate with (presumably at least "float", "double", and "long double"), and (4) the real analogues of any standard mathematical functions you want your ReIm< T >, and there you go. (N.B. For now, I've only implemented std::{real,imag,hypot,norm,abs,conj}, because those are all I need, but adding other functions should be trivial.) (Also N.B. As of now, the operators "<<" and ">>" for use with std::ostream and std::istream convert the ReIm to a std::complex< double > and use it as the operand to "<<" (resp. ">>"). If you want it better, feel free to better it.)

As an example, I like mpfr::real, from the header "real.hpp" written by Christian Schneider "<software(at)chschneider(dot)eu>". It wraps the mpfr library's arbitrary precision real arithmetic type in a templated C++ class. It's nice. It does what you think it does, the way you think it should. But std::complex< mpfr::real > is not a thing that is. In the test program "test_ReIm.cpp," I wrap an mpfr::real in a ReIm, and do mixed-precision arithmetic with it, showing interoperability with std::complex< double >. But I didn't write any code specific to mpfr::real other than to include its header. All I do is instantiate the ReIm with mpfr::real as the template parameter. There is no wrapping for me to do beyond that. Or rather, for you to do. ReIm does it for you.

Seriously, I shouldn't have had to write this. I'm going to send a sternly-worded letter to the C++ standards committee, possibly including a photograph of me shaking my fist as though I were telling damn punk kids to get off my lawn. 
